# 상품 이력 추적 블록체인 시스템 - 발표 대본 (상세 버전)

**팀명:** 코코스지
**발표자:** [발표자 이름]

---

### [Slide 1: 타이틀]
안녕하십니까, **상품 이력 추적 블록체인 시스템** 프로젝트 발표를 시작하겠습니다.
저희 팀 **코코스지**는 블록체인의 투명성을 활용하여 신뢰할 수 있는 유통 관리 솔루션을 개발했습니다.

### [Slide 2: 프로젝트 개요]
본 프로젝트의 핵심 목표는 상품의 생산부터 최종 소비자에게 전달되기까지의 **모든 유통 과정을 블록체인에 기록**하는 것입니다.
이를 위해 Node.js와 Express.js를 사용하여 서버를 구축했고, **Histories, Mine, Nodes, Transactions**라는 4가지 핵심 모듈을 구현했습니다.
특히 작업 증명(PoW)과 가장 긴 체인 규칙(Longest Chain Rule)을 직접 구현하여 데이터의 **위변조 불가능성**을 기술적으로 보장했습니다.

### [Slide 3: API 설계 - Histories Router]
첫 번째 핵심 기능인 **상품 이력 조회 API**입니다.
클라이언트가 `GET /histories/:productId`로 요청을 보내면, 서버는 해당 상품 ID(`productId`)와 연관된 모든 트랜잭션을 찾아 응답합니다.
응답 예시를 보시면, 트랜잭션 정보뿐만 아니라 해당 데이터가 **몇 번째 블록(blockIndex)**의 **어떤 해시(blockHash)**에 기록되어 있는지까지 제공하여 데이터의 신뢰성을 증명합니다.

### [Slide 4: 핵심 코드 - Histories Router]
실제 구현 코드를 보시겠습니다.
`routes/histories.js`에서는 비즈니스 로직의 복잡성을 줄이기 위해 `Blockchain` 클래스의 헬퍼 메소드인 `getTransactionsByProductId`를 호출합니다.
이 메소드는 블록체인 전체를 순회하며 조건에 맞는 트랜잭션을 필터링합니다. 만약 이력이 없다면 404 에러를, 찾았다면 JSON 형태로 데이터를 반환하는 구조입니다.

### [Slide 5: API 설계 - Mine Router]
두 번째는 블록체인의 핵심인 **블록 채굴(Mining) API**입니다.
`POST /mine` 요청 시, 채굴 보상을 받을 `minerAddress`를 파라미터로 받습니다.
이 요청이 성공하면 작업 증명이 완료된 새로운 블록 객체가 생성되어 반환됩니다. 여기에는 `nonce`, `hash`, `previousBlockHash` 등 블록 검증에 필수적인 데이터가 포함됩니다.

### [Slide 6: 핵심 코드 - Mine Router]
채굴 로직의 상세 구현입니다.
먼저 `proofOfWork` 메소드를 통해 유효한 해시를 생성하는 `nonce` 값을 찾아냅니다. 이 과정은 시간이 소요되는 작업이므로 비동기(`await`)로 처리됩니다.
`nonce`를 찾으면 `createNewBlock`으로 블록을 생성하여 체인에 연결합니다.
**중요한 점**은, 채굴에 대한 보상 트랜잭션(`MINING-REWARD`)은 현재 블록이 아닌 **다음 블록**의 처리 대기 목록에 추가된다는 점입니다. 이는 비트코인 등 실제 블록체인의 설계 원칙을 따른 것입니다.

### [Slide 7: API 설계 - Nodes Router]
세 번째는 **P2P 네트워크 관리 API**입니다.
`POST /nodes/register-and-broadcast-node`는 새로운 노드를 네트워크에 등록하고, 이를 다른 모든 노드에게 전파하는 역할을 합니다.
이를 통해 중앙 서버 없이도 노드들이 서로를 인식하고 네트워크를 확장할 수 있습니다.

### [Slide 8: 핵심 코드 - 합의 알고리즘]
분산 시스템에서 가장 중요한 **합의(Consensus) 알고리즘** 구현입니다.
`GET /consensus`가 호출되면, 서버는 네트워크상의 모든 노드에게 블록체인 데이터를 요청합니다.
받은 체인들을 검증(`chainIsValid`)하고, 현재 내 체인보다 **더 긴 유효한 체인**이 있다면 그 체인을 신뢰할 수 있는 데이터로 간주하여 내 데이터를 교체합니다. 이것이 바로 **'가장 긴 체인 규칙'**입니다.

### [Slide 9: API 설계 - Transactions Router]
네 번째는 **트랜잭션 생성 API**입니다.
`POST /transactions` 요청을 통해 발신자(`sender`), 수신자(`recipient`), 상품 ID(`productId`)를 포함한 새로운 거래를 생성합니다.
생성된 트랜잭션은 즉시 블록에 기록되는 것이 아니라, `pendingTransactions` 배열(처리 대기 목록)에 담겨 있다가 다음 채굴 시 블록에 포함됩니다.

### [Slide 10: 핵심 코드 - 트랜잭션 생성]
트랜잭션 생성 코드입니다.
요청 바디의 필수 필드를 검증한 후, `createNewTransaction` 메소드를 호출하여 고유 ID와 타임스탬프가 찍힌 트랜잭션 객체를 생성합니다.
이후 성공 응답(201 Created)과 함께 생성된 트랜잭션 정보를 클라이언트에 반환합니다.

### [Slide 11: 테스트 전략 및 결과]
저희는 시스템의 안정성을 보장하기 위해 **테스트 주도 개발(TDD)**을 수행했습니다.
`Jest`와 `Supertest`를 사용하여 단위 테스트와 통합 테스트를 작성했습니다. 특히 `axios`를 Mocking하여 실제 네트워크 없이도 P2P 통신을 검증했습니다.
그 결과, 총 **5개의 테스트 스위트와 50개의 테스트 케이스를 모두 통과(PASS)**하여 시스템의 무결성을 입증했습니다.

### [Slide 12: 결론]
결론입니다.
저희 코코스지 팀은 이번 프로젝트를 통해 블록체인의 핵심 원리를 코드로 직접 구현하고 검증했습니다.
이 시스템은 소비자가 믿을 수 있는 **투명한 유통 생태계**를 만드는 데 기여할 것입니다.
이상으로 발표를 마치겠습니다. 경청해 주셔서 감사합니다.